"""
Create a function, that accepts an arbitrary number of arrays and returns a single array generated by
alternately appending elements from the passed in arguments. If one of them is shorter than the others,
the result should be padded with empty elements.


# interleave([1, 2, 3], ["c", "d", "e"]) == [1, "c", 2, "d", 3, "e"]
# interleave([1, 2, 3], [4, 5]) == [1, 4, 2, 5, 3, None]
# interleave([1, 2, 3], [4, 5, 6], [7, 8, 9]) == [1, 4, 7, 2, 5, 8, 3, 6, 9]
# interleave([]) == []
"""
from typing import List, Any
from itertools import zip_longest, chain


def interleave(*args: List[Any]) -> List[Any]:
    """
    Examples:
        >>> assert interleave([1, 2, 3], ["c", "d", "e"]) == [1, "c", 2, "d", 3, "e"]
        >>> assert interleave([1, 2, 3], [4, 5]) == [1, 4, 2, 5, 3, None]
    """
    return [inner for top in zip_longest(*args) for inner in top]


def interleave_pythonic(*args: List[Any]) -> List[Any]:
    """
    Examples:
        >>> assert interleave_pythonic([1, 2, 3], ["c", "d", "e"]) == [1, "c", 2, "d", 3, "e"]
        >>> assert interleave_pythonic([1, 2, 3], [4, 5]) == [1, 4, 2, 5, 3, None]
    """
    return list(chain.from_iterable(zip_longest(*args)))


if __name__ == "__main__":
    print(interleave([1, 2, 3]))
    print(interleave_pythonic([1, 2, 3]))
